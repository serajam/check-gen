// Code generated by check-gen; DO NOT EDIT.
// Package password contains models and autogenerated validation code
package password

import (
	"unicode"
	"unicode/utf8"
)

// Validate validates struct accordingly to fields tags
func (u User) Validate() []string {
	var errs []string
	for _, n := range u.Name {
		if !unicode.IsLetter(n) && !unicode.IsDigit(n) && !unicode.IsPunct(n) && !unicode.IsSpace(n) {
			errs = append(errs, "name::is_not_word")
			break
		}
	}
	if utf8.RuneCountInString(u.Password) < 8 {
		errs = append(errs, "password::min_length_is::8")
	}
	if len(u.Password) > 0 {
		var PasswordUpper, PasswordLetter, PasswordNumber, PasswordSpaces, PasswordInvalidChar bool
		for _, c := range u.Password {
			if c < 33 || c > 126 {
				PasswordInvalidChar = true
				break
			}
			switch {
			case unicode.IsNumber(c):
				PasswordNumber = true
			case unicode.IsUpper(c):
				PasswordUpper = true
			case unicode.IsLetter(c):
				PasswordLetter = true
			case c == ' ':
				PasswordSpaces = true
				break
			}
		}
		if !PasswordUpper || !PasswordLetter || !PasswordNumber || PasswordSpaces || PasswordInvalidChar {
			errs = append(errs, "password::invalid_password_format")
		}
	}
	for _, n := range u.Desc {
		if !unicode.IsLetter(n) && !unicode.IsDigit(n) && !unicode.IsPunct(n) && !unicode.IsSpace(n) {
			errs = append(errs, "desc::is_not_word")
			break
		}
	}

	return errs
}

// Validate validates struct accordingly to fields tags
func (u User2) Validate() []string {
	var errs []string
	for _, n := range u.Name {
		if !unicode.IsLetter(n) && !unicode.IsDigit(n) && !unicode.IsPunct(n) && !unicode.IsSpace(n) {
			errs = append(errs, "name::is_not_word")
			break
		}
	}
	if u.PasswordRef != nil && utf8.RuneCountInString(*u.PasswordRef) < 8 {
		errs = append(errs, "password_ref::min_length_is::8")
	}
	if u.PasswordRef != nil && len(*u.PasswordRef) > 0 {
		var PasswordRefUpper, PasswordRefLetter, PasswordRefNumber, PasswordRefSpaces, PasswordRefInvalidChar bool
		for _, c := range *u.PasswordRef {
			if c < 33 || c > 126 {
				PasswordRefInvalidChar = true
				break
			}
			switch {
			case unicode.IsNumber(c):
				PasswordRefNumber = true
			case unicode.IsUpper(c):
				PasswordRefUpper = true
			case unicode.IsLetter(c):
				PasswordRefLetter = true
			case c == ' ':
				PasswordRefSpaces = true
				break
			}
		}
		if !PasswordRefUpper || !PasswordRefLetter || !PasswordRefNumber || PasswordRefSpaces || PasswordRefInvalidChar {
			errs = append(errs, "password_ref::invalid_password_format")
		}
	}
	for _, n := range u.Desc {
		if !unicode.IsLetter(n) && !unicode.IsDigit(n) && !unicode.IsPunct(n) && !unicode.IsSpace(n) {
			errs = append(errs, "desc::is_not_word")
			break
		}
	}

	return errs
}
