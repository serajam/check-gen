// Code generated by check-gen; DO NOT EDIT.
// Package examples contains models and autogenerated validation code
package examples

import (
	"fmt"
	"unicode"
	"unicode/utf8"

	"github.com/google/uuid"
)

// Validate validates struct accordingly to fields tags
func (b BoolCheck) Validate() []string {
	var errs []string
	if b.No == nil {
		errs = append(errs, "no::is_required")
	}

	return errs
}

// Validate validates struct accordingly to fields tags
func (c Custom) Validate() []string {
	var errs []string
	if c.Structs == nil || len(c.Structs) == 0 {
		errs = append(errs, "structs::is_required")
	}
	if len(c.Structs) < 1 {
		errs = append(errs, "structs::min_length_is::1")
	}
	if len(c.Structs) > 100 {
		errs = append(errs, "structs::max_length_is::100")
	}
	for _, v := range c.Structs {
		if e := v.Validate(); len(e) > 0 {
			errs = append(errs, e...)
		}
	}
	if c.Strings == nil || len(c.Strings) == 0 {
		errs = append(errs, "strings::is_required")
	}
	if len(c.Strings) < 1 {
		errs = append(errs, "strings::min_length_is::1")
	}
	if len(c.Strings) > 100 {
		errs = append(errs, "strings::max_length_is::100")
	}
	for i, v := range c.Strings {
		if utf8.RuneCountInString(v) != 15 {
			errs = append(errs, fmt.Sprintf("strings_%v::length_is_not::15", i))
		}
	}
	if c.Map == nil || len(c.Map) == 0 {
		errs = append(errs, "map::is_required")
	}
	if len(c.Map) < 1 {
		errs = append(errs, "map::min_length_is::1")
	}
	if len(c.Map) > 100 {
		errs = append(errs, "map::max_length_is::100")
	}
	for i, v := range c.Map {
		if utf8.RuneCountInString(v) != 15 {
			errs = append(errs, fmt.Sprintf("map_%v::length_is_not::15", i))
		}
	}

	return errs
}

// Validate validates struct accordingly to fields tags
func (f Float64Check) Validate() []string {
	var errs []string
	if f.Number == 0 {
		errs = append(errs, "number::is_required")
	}
	if f.Number < 1.1 {
		errs = append(errs, "number::min_value_is::1.1")
	}
	if f.Number > 1000.15 {
		errs = append(errs, "number::max_value_is::1000.15")
	}
	if f.NumberRef == nil || *f.NumberRef == 0 {
		errs = append(errs, "number_ref::is_required")
	}
	if f.NumberRef != nil && *f.NumberRef < 1 {
		errs = append(errs, "number_ref::min_value_is::1")
	}
	if f.NumberRef != nil && *f.NumberRef > 100 {
		errs = append(errs, "number_ref::max_value_is::100")
	}

	return errs
}

// Validate validates struct accordingly to fields tags
func (f Float32Check) Validate() []string {
	var errs []string
	if f.Number == 0 {
		errs = append(errs, "number::is_required")
	}
	if f.Number < 1 {
		errs = append(errs, "number::min_value_is::1")
	}
	if f.Number > 1000 {
		errs = append(errs, "number::max_value_is::1000")
	}
	if f.NumberRef == nil || *f.NumberRef == 0 {
		errs = append(errs, "number_ref::is_required")
	}
	if f.NumberRef != nil && *f.NumberRef < 1 {
		errs = append(errs, "number_ref::min_value_is::1")
	}
	if f.NumberRef != nil && *f.NumberRef > 100 {
		errs = append(errs, "number_ref::max_value_is::100")
	}

	return errs
}

// Validate validates struct accordingly to fields tags
func (i IntCheck) Validate() []string {
	var errs []string
	if i.Number == 0 {
		errs = append(errs, "number::is_required")
	}
	if i.Number < 1 {
		errs = append(errs, "number::min_value_is::1")
	}
	if i.Number > 1000 {
		errs = append(errs, "number::max_value_is::1000")
	}
	if i.NumberRef == nil || *i.NumberRef == 0 {
		errs = append(errs, "number_ref::is_required")
	}
	if i.NumberRef != nil && *i.NumberRef < 1 {
		errs = append(errs, "number_ref::min_value_is::1")
	}
	if i.NumberRef != nil && *i.NumberRef > 100 {
		errs = append(errs, "number_ref::max_value_is::100")
	}

	return errs
}

// Validate validates struct accordingly to fields tags
func (i Int64Check) Validate() []string {
	var errs []string
	if i.Number == 0 {
		errs = append(errs, "number::is_required")
	}
	if i.Number < 1 {
		errs = append(errs, "number::min_value_is::1")
	}
	if i.Number > 1000 {
		errs = append(errs, "number::max_value_is::1000")
	}
	if i.NumberRef == nil || *i.NumberRef == 0 {
		errs = append(errs, "number_ref::is_required")
	}
	if i.NumberRef != nil && *i.NumberRef < 1 {
		errs = append(errs, "number_ref::min_value_is::1")
	}
	if i.NumberRef != nil && *i.NumberRef > 100 {
		errs = append(errs, "number_ref::max_value_is::100")
	}

	return errs
}

// Validate validates struct accordingly to fields tags
func (i Int32Check) Validate() []string {
	var errs []string
	if i.Number == 0 {
		errs = append(errs, "number::is_required")
	}
	if i.Number < 1 {
		errs = append(errs, "number::min_value_is::1")
	}
	if i.Number > 1000 {
		errs = append(errs, "number::max_value_is::1000")
	}
	if i.NumberRef == nil || *i.NumberRef == 0 {
		errs = append(errs, "number_ref::is_required")
	}
	if i.NumberRef != nil && *i.NumberRef < 1 {
		errs = append(errs, "number_ref::min_value_is::1")
	}
	if i.NumberRef != nil && *i.NumberRef > 100 {
		errs = append(errs, "number_ref::max_value_is::100")
	}

	return errs
}

// Validate validates struct accordingly to fields tags
func (i Int16Check) Validate() []string {
	var errs []string
	if i.Number == 0 {
		errs = append(errs, "number::is_required")
	}
	if i.Number < 1 {
		errs = append(errs, "number::min_value_is::1")
	}
	if i.Number > 1000 {
		errs = append(errs, "number::max_value_is::1000")
	}
	if i.NumberRef == nil || *i.NumberRef == 0 {
		errs = append(errs, "number_ref::is_required")
	}
	if i.NumberRef != nil && *i.NumberRef < 1 {
		errs = append(errs, "number_ref::min_value_is::1")
	}
	if i.NumberRef != nil && *i.NumberRef > 100 {
		errs = append(errs, "number_ref::max_value_is::100")
	}

	return errs
}

// Validate validates struct accordingly to fields tags
func (i Int8Check) Validate() []string {
	var errs []string
	if i.Number == 0 {
		errs = append(errs, "number::is_required")
	}
	if i.Number < 1 {
		errs = append(errs, "number::min_value_is::1")
	}
	if i.Number > 120 {
		errs = append(errs, "number::max_value_is::120")
	}
	if i.NumberRef == nil || *i.NumberRef == 0 {
		errs = append(errs, "number_ref::is_required")
	}
	if i.NumberRef != nil && *i.NumberRef < 1 {
		errs = append(errs, "number_ref::min_value_is::1")
	}
	if i.NumberRef != nil && *i.NumberRef > 120 {
		errs = append(errs, "number_ref::max_value_is::120")
	}

	return errs
}

// Validate validates struct accordingly to fields tags
func (n NestedSliceStructCheck) Validate() []string {
	var errs []string
	if n.InnerStructSlice == nil || len(n.InnerStructSlice) == 0 {
		errs = append(errs, "inner_struct_slice::is_required")
	}
	if len(n.InnerStructSlice) < 1 {
		errs = append(errs, "inner_struct_slice::min_length_is::1")
	}
	if len(n.InnerStructSlice) > 100 {
		errs = append(errs, "inner_struct_slice::max_length_is::100")
	}
	for _, v := range n.InnerStructSlice {
		if e := v.Validate(); len(e) > 0 {
			errs = append(errs, e...)
		}
	}
	if n.InnerStructSliceRef == nil || len(n.InnerStructSliceRef) == 0 {
		errs = append(errs, "inner_struct_slice_ref::is_required")
	}
	if len(n.InnerStructSliceRef) < 1 {
		errs = append(errs, "inner_struct_slice_ref::min_length_is::1")
	}
	if len(n.InnerStructSliceRef) > 100 {
		errs = append(errs, "inner_struct_slice_ref::max_length_is::100")
	}
	for _, v := range n.InnerStructSliceRef {
		if e := v.Validate(); len(e) > 0 {
			errs = append(errs, e...)
		}
	}

	return errs
}

// Validate validates struct accordingly to fields tags
func (i Inner) Validate() []string {
	var errs []string
	if i.Name == "" {
		errs = append(errs, "name::is_required")
	}
	if utf8.RuneCountInString(i.Name) < 1 {
		errs = append(errs, "name::min_length_is::1")
	}
	if utf8.RuneCountInString(i.Name) > 100 {
		errs = append(errs, "name::max_length_is::100")
	}
	if i.Value == 0 {
		errs = append(errs, "value::is_required")
	}
	if i.Value < 1 {
		errs = append(errs, "value::min_value_is::1")
	}
	if i.Value > 100 {
		errs = append(errs, "value::max_value_is::100")
	}

	return errs
}

// Validate validates struct accordingly to fields tags
func (s SliceCheck) Validate() []string {
	var errs []string
	if s.SpacesStr == nil || len(s.SpacesStr) == 0 {
		errs = append(errs, "spaces_str::is_required")
	}
	for i, v := range s.SpacesStr {
		for _, n := range v {
			if !unicode.IsLetter(n) && !unicode.IsDigit(n) && !unicode.IsPunct(n) && !unicode.IsSpace(n) {
				errs = append(errs, fmt.Sprintf("spaces_str_%v::is_not_word", i))
				break
			}
		}
	}
	if s.SpacesInt == nil || len(s.SpacesInt) == 0 {
		errs = append(errs, "spaces_int::is_required")
	}
	if len(s.SpacesInt) < 1 {
		errs = append(errs, "spaces_int::min_length_is::1")
	}
	if len(s.SpacesInt) > 100 {
		errs = append(errs, "spaces_int::max_length_is::100")
	}
	if len(s.SpacesInt) != 100 {
		errs = append(errs, "spaces_int::length_is_not::100")
	}
	for i, v := range s.SpacesInt {
		if v < 1 {
			errs = append(errs, fmt.Sprintf("spaces_int_%d::min_value_is::1", i))
		}
		if v > 100 {
			errs = append(errs, fmt.Sprintf("spaces_int_%d::max_value_is::100", i))
		}
	}
	if s.SpacesInt8 == nil || len(s.SpacesInt8) == 0 {
		errs = append(errs, "spaces_int8::is_required")
	}
	if len(s.SpacesInt8) < 1 {
		errs = append(errs, "spaces_int8::min_length_is::1")
	}
	if len(s.SpacesInt8) > 100 {
		errs = append(errs, "spaces_int8::max_length_is::100")
	}
	if len(s.SpacesInt8) != 100 {
		errs = append(errs, "spaces_int8::length_is_not::100")
	}
	for i, v := range s.SpacesInt8 {
		if v < 1 {
			errs = append(errs, fmt.Sprintf("spaces_int8_%d::min_value_is::1", i))
		}
		if v > 100 {
			errs = append(errs, fmt.Sprintf("spaces_int8_%d::max_value_is::100", i))
		}
	}
	if s.SpacesInt16 == nil || len(s.SpacesInt16) == 0 {
		errs = append(errs, "spaces_int16::is_required")
	}
	if len(s.SpacesInt16) < 1 {
		errs = append(errs, "spaces_int16::min_length_is::1")
	}
	if len(s.SpacesInt16) > 100 {
		errs = append(errs, "spaces_int16::max_length_is::100")
	}
	if len(s.SpacesInt16) != 100 {
		errs = append(errs, "spaces_int16::length_is_not::100")
	}
	for i, v := range s.SpacesInt16 {
		if v < 1 {
			errs = append(errs, fmt.Sprintf("spaces_int16_%d::min_value_is::1", i))
		}
		if v > 100 {
			errs = append(errs, fmt.Sprintf("spaces_int16_%d::max_value_is::100", i))
		}
	}
	if s.SpacesInt32 == nil || len(s.SpacesInt32) == 0 {
		errs = append(errs, "spaces_int32::is_required")
	}
	if len(s.SpacesInt32) < 1 {
		errs = append(errs, "spaces_int32::min_length_is::1")
	}
	if len(s.SpacesInt32) > 100 {
		errs = append(errs, "spaces_int32::max_length_is::100")
	}
	if len(s.SpacesInt32) != 100 {
		errs = append(errs, "spaces_int32::length_is_not::100")
	}
	for i, v := range s.SpacesInt32 {
		if v < 1 {
			errs = append(errs, fmt.Sprintf("spaces_int32_%d::min_value_is::1", i))
		}
		if v > 100 {
			errs = append(errs, fmt.Sprintf("spaces_int32_%d::max_value_is::100", i))
		}
	}
	if s.SpacesInt64 == nil || len(s.SpacesInt64) == 0 {
		errs = append(errs, "spaces_int64::is_required")
	}
	if len(s.SpacesInt64) < 1 {
		errs = append(errs, "spaces_int64::min_length_is::1")
	}
	if len(s.SpacesInt64) > 100 {
		errs = append(errs, "spaces_int64::max_length_is::100")
	}
	if len(s.SpacesInt64) != 100 {
		errs = append(errs, "spaces_int64::length_is_not::100")
	}
	for i, v := range s.SpacesInt64 {
		if v < 1 {
			errs = append(errs, fmt.Sprintf("spaces_int64_%d::min_value_is::1", i))
		}
		if v > 100 {
			errs = append(errs, fmt.Sprintf("spaces_int64_%d::max_value_is::100", i))
		}
	}
	if s.SpacesFloat64 == nil || len(s.SpacesFloat64) == 0 {
		errs = append(errs, "spaces_float64::is_required")
	}
	if len(s.SpacesFloat64) < 1 {
		errs = append(errs, "spaces_float64::min_length_is::1")
	}
	if len(s.SpacesFloat64) > 100 {
		errs = append(errs, "spaces_float64::max_length_is::100")
	}
	if len(s.SpacesFloat64) != 100 {
		errs = append(errs, "spaces_float64::length_is_not::100")
	}
	for i, v := range s.SpacesFloat64 {
		if v < 1 {
			errs = append(errs, fmt.Sprintf("spaces_float64_%d::min_value_is::1", i))
		}
		if v > 100 {
			errs = append(errs, fmt.Sprintf("spaces_float64_%d::max_value_is::100", i))
		}
	}
	if s.SpacesFloat32 == nil || len(s.SpacesFloat32) == 0 {
		errs = append(errs, "spaces_float32::is_required")
	}
	if len(s.SpacesFloat32) < 1 {
		errs = append(errs, "spaces_float32::min_length_is::1")
	}
	if len(s.SpacesFloat32) > 100 {
		errs = append(errs, "spaces_float32::max_length_is::100")
	}
	if len(s.SpacesFloat32) != 100 {
		errs = append(errs, "spaces_float32::length_is_not::100")
	}
	for i, v := range s.SpacesFloat32 {
		if v < 1 {
			errs = append(errs, fmt.Sprintf("spaces_float32_%d::min_value_is::1", i))
		}
		if v > 100 {
			errs = append(errs, fmt.Sprintf("spaces_float32_%d::max_value_is::100", i))
		}
	}
	if s.SpacesByte == nil || len(s.SpacesByte) == 0 {
		errs = append(errs, "spaces_byte::is_required")
	}
	if len(s.SpacesByte) < 1 {
		errs = append(errs, "spaces_byte::min_length_is::1")
	}
	if len(s.SpacesByte) > 100 {
		errs = append(errs, "spaces_byte::max_length_is::100")
	}
	if len(s.SpacesByte) != 100 {
		errs = append(errs, "spaces_byte::length_is_not::100")
	}
	for i, v := range s.SpacesByte {
		if v < 1 {
			errs = append(errs, fmt.Sprintf("spaces_byte_%d::min_length_is::1", i))
		}
		if v > 100 {
			errs = append(errs, fmt.Sprintf("spaces_byte_%d::max_length_is::100", i))
		}
	}

	return errs
}

// Validate validates struct accordingly to fields tags
func (s SliceRefCheck) Validate() []string {
	var errs []string
	if s.SpacesStr == nil || len(s.SpacesStr) == 0 {
		errs = append(errs, "spaces_str::is_required")
	}
	for i, v := range s.SpacesStr {
		if v != nil {
			for _, n := range *v {
				if !unicode.IsDigit(n) {
					errs = append(errs, fmt.Sprintf("spaces_str_%v::is_not_digit", i))
					break
				}
			}
		}
	}
	if s.SpacesInt == nil || len(s.SpacesInt) == 0 {
		errs = append(errs, "spaces_int::is_required")
	}
	if len(s.SpacesInt) < 1 {
		errs = append(errs, "spaces_int::min_length_is::1")
	}
	if len(s.SpacesInt) > 100 {
		errs = append(errs, "spaces_int::max_length_is::100")
	}
	if len(s.SpacesInt) != 100 {
		errs = append(errs, "spaces_int::length_is_not::100")
	}
	for i, v := range s.SpacesInt {
		if *v < 1 {
			errs = append(errs, fmt.Sprintf("spaces_int_%d::min_value_is::1", i))
		}
		if *v > 100 {
			errs = append(errs, fmt.Sprintf("spaces_int_%d::max_value_is::100", i))
		}
	}
	if s.SpacesInt8 == nil || len(s.SpacesInt8) == 0 {
		errs = append(errs, "spaces_int8::is_required")
	}
	if len(s.SpacesInt8) < 1 {
		errs = append(errs, "spaces_int8::min_length_is::1")
	}
	if len(s.SpacesInt8) > 100 {
		errs = append(errs, "spaces_int8::max_length_is::100")
	}
	if len(s.SpacesInt8) != 100 {
		errs = append(errs, "spaces_int8::length_is_not::100")
	}
	for i, v := range s.SpacesInt8 {
		if *v < 1 {
			errs = append(errs, fmt.Sprintf("spaces_int8_%d::min_value_is::1", i))
		}
		if *v > 100 {
			errs = append(errs, fmt.Sprintf("spaces_int8_%d::max_value_is::100", i))
		}
	}
	if s.SpacesInt16 == nil || len(s.SpacesInt16) == 0 {
		errs = append(errs, "spaces_int16::is_required")
	}
	if len(s.SpacesInt16) < 1 {
		errs = append(errs, "spaces_int16::min_length_is::1")
	}
	if len(s.SpacesInt16) > 100 {
		errs = append(errs, "spaces_int16::max_length_is::100")
	}
	if len(s.SpacesInt16) != 100 {
		errs = append(errs, "spaces_int16::length_is_not::100")
	}
	for i, v := range s.SpacesInt16 {
		if *v < 1 {
			errs = append(errs, fmt.Sprintf("spaces_int16_%d::min_value_is::1", i))
		}
		if *v > 100 {
			errs = append(errs, fmt.Sprintf("spaces_int16_%d::max_value_is::100", i))
		}
	}
	if s.SpacesInt32 == nil || len(s.SpacesInt32) == 0 {
		errs = append(errs, "spaces_int32::is_required")
	}
	if len(s.SpacesInt32) < 1 {
		errs = append(errs, "spaces_int32::min_length_is::1")
	}
	if len(s.SpacesInt32) > 100 {
		errs = append(errs, "spaces_int32::max_length_is::100")
	}
	if len(s.SpacesInt32) != 100 {
		errs = append(errs, "spaces_int32::length_is_not::100")
	}
	for i, v := range s.SpacesInt32 {
		if *v < 1 {
			errs = append(errs, fmt.Sprintf("spaces_int32_%d::min_value_is::1", i))
		}
		if *v > 100 {
			errs = append(errs, fmt.Sprintf("spaces_int32_%d::max_value_is::100", i))
		}
	}
	if s.SpacesInt64 == nil || len(s.SpacesInt64) == 0 {
		errs = append(errs, "spaces_int64::is_required")
	}
	if len(s.SpacesInt64) < 1 {
		errs = append(errs, "spaces_int64::min_length_is::1")
	}
	if len(s.SpacesInt64) > 100 {
		errs = append(errs, "spaces_int64::max_length_is::100")
	}
	if len(s.SpacesInt64) != 100 {
		errs = append(errs, "spaces_int64::length_is_not::100")
	}
	for i, v := range s.SpacesInt64 {
		if *v < 1 {
			errs = append(errs, fmt.Sprintf("spaces_int64_%d::min_value_is::1", i))
		}
		if *v > 100 {
			errs = append(errs, fmt.Sprintf("spaces_int64_%d::max_value_is::100", i))
		}
	}
	if s.SpacesFloat64 == nil || len(s.SpacesFloat64) == 0 {
		errs = append(errs, "spaces_float64::is_required")
	}
	if len(s.SpacesFloat64) < 1 {
		errs = append(errs, "spaces_float64::min_length_is::1")
	}
	if len(s.SpacesFloat64) > 100 {
		errs = append(errs, "spaces_float64::max_length_is::100")
	}
	if len(s.SpacesFloat64) != 100 {
		errs = append(errs, "spaces_float64::length_is_not::100")
	}
	for i, v := range s.SpacesFloat64 {
		if *v < 1 {
			errs = append(errs, fmt.Sprintf("spaces_float64_%d::min_value_is::1", i))
		}
		if *v > 100 {
			errs = append(errs, fmt.Sprintf("spaces_float64_%d::max_value_is::100", i))
		}
	}
	if s.SpacesFloat32 == nil || len(s.SpacesFloat32) == 0 {
		errs = append(errs, "spaces_float32::is_required")
	}
	if len(s.SpacesFloat32) < 1 {
		errs = append(errs, "spaces_float32::min_length_is::1")
	}
	if len(s.SpacesFloat32) > 100 {
		errs = append(errs, "spaces_float32::max_length_is::100")
	}
	if len(s.SpacesFloat32) != 100 {
		errs = append(errs, "spaces_float32::length_is_not::100")
	}
	for i, v := range s.SpacesFloat32 {
		if *v < 1 {
			errs = append(errs, fmt.Sprintf("spaces_float32_%d::min_value_is::1", i))
		}
		if *v > 100 {
			errs = append(errs, fmt.Sprintf("spaces_float32_%d::max_value_is::100", i))
		}
	}
	if s.SpacesByte == nil || len(s.SpacesByte) == 0 {
		errs = append(errs, "spaces_byte::is_required")
	}
	if len(s.SpacesByte) < 1 {
		errs = append(errs, "spaces_byte::min_length_is::1")
	}
	if len(s.SpacesByte) > 100 {
		errs = append(errs, "spaces_byte::max_length_is::100")
	}
	if len(s.SpacesByte) != 100 {
		errs = append(errs, "spaces_byte::length_is_not::100")
	}
	for i, v := range s.SpacesByte {
		if *v < 1 {
			errs = append(errs, fmt.Sprintf("spaces_byte_%d::min_length_is::1", i))
		}
		if *v > 100 {
			errs = append(errs, fmt.Sprintf("spaces_byte_%d::max_length_is::100", i))
		}
	}

	return errs
}

// Validate validates struct accordingly to fields tags
func (s StringCheck) Validate() []string {
	var errs []string
	if s.Name == "" {
		errs = append(errs, "name::is_required")
	}
	if utf8.RuneCountInString(s.Name) < 1 {
		errs = append(errs, "name::min_length_is::1")
	}
	if utf8.RuneCountInString(s.Name) > 20 {
		errs = append(errs, "name::max_length_is::20")
	}
	if utf8.RuneCountInString(s.Name) != 10 {
		errs = append(errs, "name::length_is_not::10")
	}
	if s.NameRef == nil || len(*s.NameRef) == 0 {
		errs = append(errs, "name_ref::is_required")
	}
	if s.NameRef != nil && utf8.RuneCountInString(*s.NameRef) < 1 {
		errs = append(errs, "name_ref::min_length_is::1")
	}
	if s.NameRef != nil && utf8.RuneCountInString(*s.NameRef) > 20 {
		errs = append(errs, "name_ref::max_length_is::20")
	}
	if s.SurnameRef != nil && utf8.RuneCountInString(*s.SurnameRef) < 1 {
		errs = append(errs, "surname_ref::min_length_is::1")
	}
	if s.SurnameRef != nil && utf8.RuneCountInString(*s.SurnameRef) > 20 {
		errs = append(errs, "surname_ref::max_length_is::20")
	}
	if s.SurnameRef != nil && utf8.RuneCountInString(*s.SurnameRef) != 100 {
		errs = append(errs, "surname_ref::length_is_not::100")
	}
	if s.IdRef != nil && utf8.RuneCountInString(*s.IdRef) < 1 {
		errs = append(errs, "id_ref::min_length_is::1")
	}
	if s.IdRef != nil && utf8.RuneCountInString(*s.IdRef) > 1000 {
		errs = append(errs, "id_ref::max_length_is::1000")
	}
	if s.IdRef != nil && utf8.RuneCountInString(*s.IdRef) != 100 {
		errs = append(errs, "id_ref::length_is_not::100")
	}
	if s.NumberStringRef == nil || len(*s.NumberStringRef) == 0 {
		errs = append(errs, "number_string_ref::is_required")
	}
	if s.NumberStringRef != nil {
		for _, n := range *s.NumberStringRef {
			if !unicode.IsDigit(n) {
				errs = append(errs, "number_string_ref::is_not_digit")
				break
			}
		}
	}
	if s.NumberString == "" {
		errs = append(errs, "number_string::is_required")
	}
	if utf8.RuneCountInString(s.NumberString) != 5 {
		errs = append(errs, "number_string::length_is_not::5")
	}
	if s.StringAllnumRef == nil || len(*s.StringAllnumRef) == 0 {
		errs = append(errs, "string_allnum_ref::is_required")
	}
	if s.StringAllnumRef != nil {
		for _, n := range *s.StringAllnumRef {
			if !unicode.IsLetter(n) && !unicode.IsDigit(n) && !unicode.IsPunct(n) && !unicode.IsSpace(n) {
				errs = append(errs, "string_allnum_ref::is_not_word")
				break
			}
		}
	}
	if s.StringAllnum == "" {
		errs = append(errs, "string_allnum::is_required")
	}
	for _, n := range s.StringAllnum {
		if !unicode.IsLetter(n) && !unicode.IsDigit(n) && !unicode.IsPunct(n) && !unicode.IsSpace(n) {
			errs = append(errs, "string_allnum::is_not_word")
			break
		}
	}
	if s.Test != "" {
		if _, err := uuid.Parse(s.Test); err != nil {
			errs = append(errs, "test::is_not_uuid")
		}
	}
	if s.TestRef != nil {
		if _, err := uuid.Parse(*s.TestRef); err != nil {
			errs = append(errs, "test_ref::is_not_uuid")
		}
	}
	if s.UTest == nil || len(s.UTest) == 0 {
		errs = append(errs, "utest::is_required")
	}
	for i, v := range s.UTest {
		if v != "" {
			if _, err := uuid.Parse(v); err != nil {
				errs = append(errs, fmt.Sprintf("utest_%v::is_not_uuid", i))
			}
		}
	}
	if s.UTestRef == nil || len(s.UTestRef) == 0 {
		errs = append(errs, "utest_ref::is_required")
	}
	for i, v := range s.UTestRef {
		if v != nil {
			if _, err := uuid.Parse(*v); err != nil {
				errs = append(errs, fmt.Sprintf("utest_ref_%v::is_not_uuid", i))
			}
		}
	}
	if s.WTest == nil || len(s.WTest) == 0 {
		errs = append(errs, "wtest::is_required")
	}
	for i, v := range s.WTest {
		for _, n := range v {
			if !unicode.IsLetter(n) && !unicode.IsDigit(n) && !unicode.IsPunct(n) && !unicode.IsSpace(n) {
				errs = append(errs, fmt.Sprintf("wtest_%v::is_not_word", i))
				break
			}
		}
	}
	if s.WTestRef == nil || len(s.WTestRef) == 0 {
		errs = append(errs, "wtest_ref::is_required")
	}
	for i, v := range s.WTestRef {
		if v != nil {
			for _, n := range *v {
				if !unicode.IsLetter(n) && !unicode.IsDigit(n) && !unicode.IsPunct(n) && !unicode.IsSpace(n) {
					errs = append(errs, fmt.Sprintf("wtest_ref_%v::is_not_word", i))
					break
				}
			}
		}
	}
	if s.DTest == nil || len(s.DTest) == 0 {
		errs = append(errs, "dtest::is_required")
	}
	for i, v := range s.DTest {
		for _, n := range v {
			if !unicode.IsDigit(n) {
				errs = append(errs, fmt.Sprintf("dtest_%v::is_not_digit", i))
				break
			}
		}
	}
	if s.DTestRef == nil || len(s.DTestRef) == 0 {
		errs = append(errs, "dtest_ref::is_required")
	}
	for i, v := range s.DTestRef {
		if v != nil {
			for _, n := range *v {
				if !unicode.IsDigit(n) {
					errs = append(errs, fmt.Sprintf("dtest_ref_%v::is_not_digit", i))
					break
				}
			}
		}
	}
	if s.SpacesMapString == nil || len(s.SpacesMapString) == 0 {
		errs = append(errs, "spaces_map_string::is_required")
	}

	return errs
}

// Validate validates struct accordingly to fields tags
func (n Nested) Validate() []string {
	var errs []string
	if n.Name == "" {
		errs = append(errs, "name::is_required")
	}
	if utf8.RuneCountInString(n.Name) < 1 {
		errs = append(errs, "name::min_length_is::1")
	}
	if utf8.RuneCountInString(n.Name) > 100 {
		errs = append(errs, "name::max_length_is::100")
	}
	if n.Value == 0 {
		errs = append(errs, "value::is_required")
	}
	if n.Value < 1 {
		errs = append(errs, "value::min_value_is::1")
	}
	if n.Value > 100 {
		errs = append(errs, "value::max_value_is::100")
	}

	return errs
}

// Validate validates struct accordingly to fields tags
func (n NestedStructCheck) Validate() []string {
	var errs []string
	if e := n.NestedStruct.Validate(); len(e) > 0 {
		errs = append(errs, e...)
	}
	if n.NestedStructRefCheck == nil {
		errs = append(errs, "nested_struct_ref_check::is_required")
	}
	if n.NestedStructRefCheck != nil {
		if e := n.NestedStructRefCheck.Validate(); len(e) > 0 {
			errs = append(errs, e...)
		}
	}

	return errs
}
